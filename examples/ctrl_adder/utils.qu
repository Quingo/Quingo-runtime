import std_ops

operation get_bin(val: int, width: int) : int[] {
    int[width] res;
    for (int i = 0; i < width; i += 1) {
        res[i] = val % 2;
        val = val / 2;
    }
    return res;
}

// left shift the binary string `a` for `amount` bits, a -> a * 2^amount
// example:
//   (0b0011110, 2)  -> 0b1111000
// note, a is stored as [0,1,1,1,1,0,0], the result is [0,0,0,1,1,1,1]
operation left_shift(a: int[], amount: int) : int[] {
    int len_a = a.length;
    int[len_a] b;

    for (int i = 0; i < amount; i += 1) {
        b[i] = 0;
    }

    for (int j = amount; j < len_a; j += 1) {
        b[j] = a[j - amount];
    }

    return b;
}

// right shift the binary string `a` for `amount` bits, i.e., a -> a / 2^amount
// example:
//   (0b0011110, 2)  -> 0b0000111
// note, a is stored as [0,1,1,1,1,0,0], the result is [1,1,1,0,0,0,0]
operation right_shift(a: int[], amount: int) : int[] {
    int len_a = a.length;
    int[len_a] b;

    for (int i = 0; i < len_a - amount; i += 1) {
        b[i] = a[i + amount];
    }

    for (int j = len_a - amount; j < len_a; j += 1) {
        b[j] = 0;
    }

    return b;
}

operation load_integer(i_val: int, qs: qubit[]) : unit {
    int width = qs.length;
    int[] bits = get_bin(i_val, width);
    for (int i = 0; i < width; i += 1) {
        if (bits[i] == 1) {
            X(qs[i]);
        }
    }
}



